
writeExpression :: Expression -> Compiler [Instruction]     -- or should it be Compiler () ?
writeExpression (If condition trueValue falseValue) = 
    genLabel >>= \elseLabel             ->
    genLabel >>= \endifLabel            ->
    writeExpression condition           >>
    writeInstruction (Jz elseLabel)     >>
    writeExpression trueValue           >>
    writeInstruction (Jump endifLabel)  >>
    writeInstruction (Label elseLabel)  >>
    writeExpression falseValue          >>
    writeInstruction (Label endifLabel)


data CompilerState = CompilerState {                   
                        labelCounter :: Integer,       
                        instructions :: [Instruction] }
    
type Compiler a = State CompilerState a

genLabel :: Compiler String
genLabel = do state <- get
              counter <- labelCounter state
              put (state { labelCounter = counter + 1 } )
              return $ '~':(show counter)
    
writeInstruction :: Instruction -> Compiler ()
writeInstruction = do state <- get
                      ins <- instructions state
                      put (state { instructions = ins:instructions } )
  
    
============================================
    
data CompilerState = CompilerState {                        -- possibly include info 
                        labelCounter :: Integer,            -- about symbol tables too.
                        instructions :: [Instruction] }

newtype Compiler a = { runCompiler :: CompilerState -> Either String (a, CompilerState) }

instance Monad Compiler where
    
    return a = Compiler (\s -> Right (a, s))
    
    c1 >>= fc2 = Compiler $
                    \initState ->
                        case (runCompiler c1 initState) of
                            Left err -> Left err
                            Right (result, newState) -> runCompiler (fc2 result) newState

getState :: Compiler CompilerState                   
getState = Compiler $ \s -> Right (s, s)

putState :: CompilerState -> Compiler ()
putState s = Compiler $ \s -> Right ((), s)

genLabel :: Compiler String
genLabel = do state <- getCompilerState
              counter <- labelCounter state
              putState (state {labelCounter = counter + 1})
              return $ '~':(show counter)
              

==============================================

steps:
    * Combine modules into one
    * Separate variable, function, and assembly macro definitions
    * Convert all VarInts and VarStrings into VarArrays
    
    * Ensure no variable is defined twice
    * Ensure no two functions and assembly macros have the same name.
    * Ensure all function calls refer to defined functions or assembly macros
    * Ensure all symbol expressions refer to defined variables or parameters
    * Ensure all function calls have the correct number of arguments
    * Ensure main function or assembly macro is defined
    
    * make heap symbol table.
            association list mapping names to heap addresses
            
    * write heap variables at calculated offsets
            
            var x = (1 2 3) / address 6
            
            push 6
            push 1
            store
            push 7
            push 2
            store
            push 8
            push 3
            store
            
    * write address of next free heap element
      at address 0.
      
            n = total length of all VarArray data + 1
      
            push 0
            push n
            store
            
    * write "jump main"
                            
    * write functions
    
            make stack symbol table
            write the function expression, with stack offset 0, identifier = name of function
            write "ret" instruction

    * write literal expression
            push value of expression directly on stack.
 
    * write symbol expression
            
            if symbol is on the stack
                
                    calculate stack address and write copy instruction.
                    
                    addr = index on stack symbol table
                         + stack offset
                         
                    copy addr
            
            if symbol is on the heap
            
                    push address from heap symbol table

    * write if expression
    
            generate else label    (concat . intersperse '-') ("else":identifier)
            generate endif label   (concat . intersperse '-') ("endif":identifier)
            
            write condition
            write "jz else"
            write trueValue
            write "jump endif"
            write "label else"
            write falseValue
            write "label endif"
            
    * write function call
    
            write each argument expression, left to right,
            incrementing stack offset each time.
            subexpression identifier = (show stack offset) : identifier
            write "call function"
            write "slide n", where n = # of arguments passed.
            
    * write assembly macro call
        
            write each argument expression, left to right,
            incrementing stack offset each time.
            copy macro instructions
            write "slide n", where n = # of arguments passed.
            
    * write "end" instruction
        
    
=======================================

alternatively, parseFile could return
a list of modules, and it's the responsibility
of the compiler to combine them.

parseFile :: [FilePath] -> FilePath -> IO Module
parseFile importedFiles filename = do
    text <- readFile filename
    let m@(Module imports _) = parseModule filename text
    filesNotImported = filter (\x -> not x `elem` importedFiles) imports
    let ioms = map (parseFile (filename:importedFiles)) filesNotImported
    ms <- sequence ioms
    return $ combineModules (m:ms)

combineModules :: [Module] -> Module
combineModules ms = Module [] (elements ms)
                  where elements ((Module _ es):[]) = es
                        elements ((Module _ es):ms) = es ++ (elements ms)



========================================

data Module = Module [FilePath] [Element]

data Element = VarInt    Integer
             | VarArray  [Integer]
             | VarString String
             | Function String [String] Expression
             | AssemblyMacro String [String] [Instruction]

data Expression = AtomVal Integer
                | AtomVar String
                | Call String [Expression]
                | If Expression Expression Expression
                
data Instruction = Push Integer
                 | Dup
                 | Copy Integer
                 | Swap
                 | Pop
                 | Slide Integer
                 | Add
                 | Sub
                 | Mul
                 | Div
                 | Mod
                 | Store
                 | Load
                 | Label String
                 | Call String
                 | Jump String
                 | Jz String
                 | Jn String
                 | Ret
                 | End
                 | Pc
                 | Pn
                 | Rc
                 | Rn

==================================

<module> -> { <import> } { <element> }

<import> -> 'import' stringLiteral

<element> -> <variable> | <function> | <assembly macro>

<variable> -> 'var' <identifier> '=' <heapvalue>
<heapvalue> -> <number> | <array> | <string>

<function> -> 'def' <identifier> <parameters> '=' <expression>
<assembly macro> -> 'asm' <identifier> <parameters> '=' '(' { <instruction> } ')'
<parameters> -> '(' { <identifier> } ')'

<instruction> -> 'push' <number>
                 'dup'
                 'copy' <number>
                 'swap'
                 'pop'
                 'slide' <number>
                 'add'
                 'sub'
                 'mul'
                 'div'
                 'mod'
                 'store'
                 'load'
                 'label' <label>
                 'call' <label>
                 'jump' <label>
                 'jz' <label>
                 'jn' <label>
                 'ret'
                 'end'
                 'pc'
                 'pn'
                 'rc'
                 'rn'

<expression> -> <atom> | <call> | <if>
<atom> -> <number> | <identifier>
<call> -> '(' <identifier> { <expression> } ')'
<if> -> '(' 'if' <expression> <expression> <expression> ')'

<label> -> <identifier>            
<number> -> integral or character literal
<string> -> string literal
<array> -> '(' { <number> } ')'


<identifier> -> <identStart> { <identLetter> }
<identStart> -> [a-zA-Z!@#$%^&*-_=+\|:,<.>/?]
<identLetter> -> <identStart> | [0-9]

Identifier constraints:
~     -only for system-generated identifiers
;     -reserved for comments
'"    -for character & string literals only
()    -reserved for grouping expressions
[] {} -probably best left unused
0-9   -start of identifier can't be numeric