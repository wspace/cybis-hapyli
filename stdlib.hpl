
;;;========== ARITHMETIC ==========

asm inline +  (x y) = ( add )
asm inline ++ (x)   = ( push 1 add )
asm inline -  (x y) = ( sub )
asm inline -  (x)   = ( push 0 swap sub )
asm inline -- (x)   = ( push 1 sub )
asm inline *  (x y) = ( mul )
asm inline /  (x y) = ( div )
asm inline %  (x y) = ( mod )




;;;========== IO ==========

var *__STDLIB_INPUT_BUFFER = 0

asm inline print-number (n) = ( dup pn )
asm inline print-char (c) = ( dup pc )

def print-string (*str) = 
let
    c = (ref *str)
in
    (if c
        (do (print-char c)
            (print-string (++ *str))
            *str)
        *str)

asm inline read-number (*buffer) = ( dup rn load )
asm inline read-char (*buffer) = ( dup rc load )

def inline read-number () = (read-number *__STDLIB_INPUT_BUFFER)
def inline read-char () = (read-char *__STDLIB_INPUT_BUFFER)



    


;;;========== HEAP ==========

asm inline ref (*address)         = ( load )
asm inline ref (*array index) = ( add load )

asm inline set (*address value) = (
    
    ;; Store the value at the address.
    copy 1      ; (*address value *address)
    copy 1      ; (*address value *address value)
    store       ; (*address value)
    
    ;; Return the value we stored.
    slide 1     ; (value)

)

asm inline set (*array index value) = (

    ;; Get the address at which to store the value.
    copy 2      ; (*array index value *array)         
    copy 2      ; (*array index value *array index)
    add         ; (*array index value *address)

    ;; Store the value at the computed address.
    copy 1      ; (*array index value *address value)
    store       ; (*array index value)
    
    ;; Return the value we stored.
    slide 2     ; (value)
)

asm inline alloc (size) = (
    
    ;; Load HaPyLi's heap pointer.
    ;; The address of unallocated heap memory is stored at 0. 
    push 0      ; (size *heap)
    load        ; (size *unallocated)
    
    ;; Compute the range of addresses to allocate.
    ;; *from = starting address.
    ;; *to   = ending address, exclusive.
                ; (size *from)
    swap        ; (*from size)
    copy 1      ; (*from size *from)
    add         ; (*from *to)
    
    ;; Allocate all memory in the computed range.
    dup         ; (*from *to *to)
    push 0      ; (*from *to *to 0)
    store       ; (*from *to)
    
    ;; Set the heap pointer to the new address of
    ;; unallocated memory.
                ; (*allocated *unallocated)
    push 0      ; (*allocated *unallocated *heap)
    swap        ; (*allocated *heap *unallocated)
    store       ; (*allocated)
    
    ;; Return the address of the newly allocated memory.
)

